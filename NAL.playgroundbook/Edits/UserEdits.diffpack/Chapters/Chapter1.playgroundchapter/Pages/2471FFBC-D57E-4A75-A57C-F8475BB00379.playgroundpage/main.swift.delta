<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>BaseFile</key>
	<string>Chapters/Chapter1.playgroundchapter/Pages/Template.playgroundpage/main.swift</string>
	<key>Diffs</key>
	<array>
		<dict>
			<key>ModifiedContent</key>
			<string>
// military uses made up language to teach their staff
// use it to teach nars

// pseudo code for Narsese -&gt; Swift compiler
// transform narsese Sentence into a valid Swift string
// terms become variables: `car` -&gt; `let car = Term.word("car")`
extension Term {
    public var swift: String {
        var id = ""
        switch self {
        case .word:
            id = ".word"
        case .compound:
            id = ".compound"
        }
        return "`let \(description) = \(type(of: self))\(id)(\"\(description)\")"
    }
    public var compoundStatement: Statement? {
        switch self {
        case .word: return nil
        case .compound(let connector, let terms):
            if terms.count == 2, let copula = Copula(rawValue: connector.description) {
                return copula.makeStatement(terms[0], terms[1])
            } else {
                return nil
            }
        }
    }
}

import Foundation
extension Term {
    public init?(s: String) {
        let words = s.components(separatedBy: " ")
        if words.count == 3, let copula = Copula(rawValue: words[1]), let t1 = Term(s: words[0]), let t2 = Term(s: words[2]) {
            self = .compound(copula.term, [t1, t2])
        } else if words.count &gt; 1, let connector = Connector(rawValue: words[0]) {
            let terms = words.dropFirst().compactMap(Term.init(s:))
            if !terms.isEmpty {
                self = .compound(connector.term, terms)
            } else {
                return nil
            }
        } else if words.count == 1, Copula(rawValue: words[0]) == nil {
            self = .word(words[0])
        } else {
            return nil
        }
    }
    var copula: Copula? { Copula(rawValue: description) }
}
extension Copula {
    var term: Term { Term.word(rawValue) }
}
extension Connector {
    var term: Term! { Term.word(rawValue) }
}


// experimental
let bird = Term.word("bird")
let animal = Term.word("animal")
let mammal = Term.word("mammal")

print("Swift: ", mammal.swift) 
let compound = Term.compound(.word(Copula.inheritance.rawValue), [bird, animal])
print("Swift: ", compound.swift)
let reproduced = Term(s: compound.description)
print("Swift: ", reproduced == compound)
print("Swift: ", reproduced?.compoundStatement)






/// rule as a matrix of optional booleans
/// true identifies common term
[
    false, true,
    true , nil ,
    nil  , false
]

/// test sequence is a dual
/// A -&gt; B
/// B -&gt; C
/// first symbol is `false`, second is `nil
/// if there is no common term term identified by `true`
/// then a conclusion could not be derived
[
    false, true,
    true, nil
]

/// Optional&lt;Bool&gt; is represented as a Triple
let common = true
let first = false
var second: Bool?
[
    false, nil, true
] // OR 
[ // as a list of terms
    first, second, common
]

/// if there is a false then there is at least one type of symbol present 
/// if there is a second then all are not repeats
/// if there is no common term then a rule could not be applied
/// otherwise this term is a common


/// Optional&lt;Bool&gt; quad where 0 &amp; 1 are false &amp; true
[
    nil, false, true, nil
]




/// opens a `var`iable channel that changes over time
/// synchronized to system clock
var channel: Optional&lt;Bool&gt; {
    true
}


/// open an immutable channel 
/// can represent eternal statements or questions:
let immutableChannel: Sentence = ("A"--&gt;"B")-* // -?


///
/// if narsese can be translated to swift
/// then a well-formed narsese sentence must compile
///

/// operations can be expressed as functions 
/// assigned to a variable like above
/// variable name is the name of operation in nars
/// source code stored elsewhere
/// 



func validate(a: Term, 
              b: Term, 
              c: Term, 
              d: Term) -&gt; Bool {
    print(a --&gt; b)
    print(b --&gt; d)
    return false
}
//print("--")
//validate(a: test1.subject, 
//         b: test1.predicate, 
//         c: test2.subject, 
//         d: test2.predicate)
//print(t1.copula == s1.copula)
//print(t2.copula == s2.copula)
//print(s1.copula.makeStatement(t1.subject, t1.predicate))
//print(s2.copula.makeStatement(t2.subject, t2.predicate))
</string>
			<key>ModifiedRange</key>
			<string>{1, 4156}</string>
			<key>OriginalContent</key>
			<string></string>
			<key>OriginalRange</key>
			<string>{1, 0}</string>
		</dict>
	</array>
	<key>FormatVersion</key>
	<integer>2</integer>
</dict>
</plist>
