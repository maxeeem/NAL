<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>BaseFile</key>
	<string>Chapters/Chapter1.playgroundchapter/Pages/Template.playgroundpage/main.swift</string>
	<key>Diffs</key>
	<array>
		<dict>
			<key>ModifiedContent</key>
			<string>
/// rule as a matrix of optional booleans
/// true identifies common term
[
    false, true,
    true , nil ,
    nil  , false
]

/// test sequence is a dual
/// A -&gt; B
/// B -&gt; C
/// first symbol is `false`, second is `nil
/// if there is no common term term identified by `true`
/// then a conclusion could not be derived
[
    false, true,
    true, nil
]

/// Optional&lt;Bool&gt; is represented as a Triple
let common = true
let first = false
var second: Bool?
[
    false, nil, true
] // OR 
[ // as a list of terms
    first, second, common
]

/// if there is a false then there is at least one type of symbol present 
/// if there is a second then all are not repeats
/// if there is no common term then a rule could not be applied
/// otherwise this term is a common


/// Optional&lt;Bool&gt; quad where 0 &amp; 1 are false &amp; true
[
    nil, false, true, nil
]




/// opens a `var`iable channel that changes over time
/// synchronized to system clock
var channel: Optional&lt;Bool&gt; {
    true
}


/// open an immutable channel 
/// can represent eternal statements or questions:
let immutableChannel: Sentence = ("A"--&gt;"B")-* // -?


///
/// if narsese can be translated to swift
/// then a well-formed narsese sentence must compile
///

/// operations can be expressed as functions 
/// assigned to a variable like above
/// variable name is the name of operation in nars
/// source code stored elsewhere
/// 



func validate(a: Term, 
              b: Term, 
              c: Term, 
              d: Term) -&gt; Bool {
    print(a --&gt; b)
    print(b --&gt; d)
    return false
}
//print("--")
//validate(a: test1.subject, 
//         b: test1.predicate, 
//         c: test2.subject, 
//         d: test2.predicate)
//print(t1.copula == s1.copula)
//print(t2.copula == s2.copula)
//print(s1.copula.makeStatement(t1.subject, t1.predicate))
//print(s2.copula.makeStatement(t2.subject, t2.predicate))
</string>
			<key>ModifiedRange</key>
			<string>{1, 1888}</string>
			<key>OriginalContent</key>
			<string></string>
			<key>OriginalRange</key>
			<string>{1, 0}</string>
		</dict>
	</array>
	<key>FormatVersion</key>
	<integer>2</integer>
</dict>
</plist>
